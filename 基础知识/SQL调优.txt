~mysql选用B+树作为索引的数据结构的原因
 从数据结果来讲，如果访问每个节点的开销一样的话，二叉搜索树访问的次数是最少效率最高的，
 但是索引在大数据量的情况下可能达到几个G，所以索引是存放在磁盘上面的，而对磁盘进行IO是
 很耗时的操作，所以索引提高速度的关键是减少IO的次数，而IO次数和树的高度相关，这样每个节点
 就必须就要尽可能多的存储数据,并且树的高度要尽可能的小，B树每层节点数目非常多，层数很少刚好符合
 这个特征，使用B+树的原因是B+树所有的数据都存储在叶子节点，索引不会存储数据比较文档，并且叶子
 节点从小到大会形成一个链表，做范围搜索的时候只需要根据链表遍历即可，查询效率高.
  
~mysql存储引擎的区别
 innoDb:
        >mysql5.5之后默认的存储引擎，支持行级锁(不绝对使用like关键字修改数据同样会锁表)，对高并发支持较好.
		>支持事务
        >支持外键，使用聚集索引，不会存储行数,不支持全文索引,InnoDB表比MyISAM表更安全
 myIASM:
        >支持表级锁
		>默认会存储总行数
		>支持全文索引

~mysql数据库的调优注意点
 >禁止使用全表的范围查询 != > < 以及 IS NULL值
 >禁止对索引字段进行函数或者数学运算操作
 >在条件查询和排序列上建立索引
 >联合索引的最左匹配原则
 >避免使用like关键字特别是Insert的时候
 >查询时要精简字段，尽量返回需要的字段
 >避免全字段update，只update
 >拆分大的 DELETE 或INSERT 语句 避免锁表

~数据库的隔离级别  (原子性，一致性)
 >脏读
 >幻读
 >不可重复读
 
~SQL关键字的执行顺序

~什么时候建索引
	>主键自动创建唯一索引
	>频繁作为查询条件的字段应该创建索引
	>查询中与其他表关联的字段，外键关系建立索引
	>单键/组合索引的问题，组合索引性价比更高
	>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度
	>查询中统计或分组字段.

 不需要建索引
    >表记录太少
    >增删改的表或者字段
    >where条件里用不到的字段不需要创建索引
    >区分度不高的字段一般不做索引 区分度的公式{SELECT count(distinct [COL] )/count(*) FROM [TABLE] }<0.1




select count(*) from [TABLE] 
在默认的innoDB mysql引擎下 300万数据大概耗时2.7s
【1】存在ID自增主键，表记录不删除的情况下  直接查询最后一条记录ID即可

     
